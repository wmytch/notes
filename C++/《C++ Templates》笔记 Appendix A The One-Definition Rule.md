# Appendix A The One-Definition Rule

[TOC]

ODR(one-definition rule)，作为C++程序里良构结构的基石，具体指的是：

- 非inline的函数或对象在所有文件中只定义一次；
- 类、inline的函数和inline的变量在一个翻译单元中最多只定义一次；
- 确保对同一个实体的所有定义的一致。

然而，魔鬼在细节中。

## A.1 Translation Units

一个翻译单元，是输送给编译器的文件经过预处理的结果。

预处理会对文件做一些处理：
- 丢弃掉条件编译导言(`#if`,`#ifdef`,以及友元)排除掉的代码块。
- 丢弃注释
- （递归)插入`#include`的文件
- 扩展宏

比方说对这两个文件

```c++
\\header.hpp
#ifdef DO_DEBUG
#define debug(x) std::cout<<x<<std::endl
#else
#define debug(x)
#endif
    
void debugInit();
```

```c++
\\myprog.cpp
#include "header.hpp"
    
int main()
{
    debugInit():
    debug("main()");
}
```

如果在别的地方没有`#define DO_DEBUG`也没有在编译参数中带上`-DDO_DEBUG`，那么翻译单元就等同于这么一个单独的文件

```c++
//myprog.cpp
void debugInit();

int main()
{
    debugInit();
}
```

可见，一个翻译单元并不只是一个文件。但也不仅仅是一个预处理后的文件，比方说，如果我们把一个预处理后的文件两次输送给编译器，那么对编译器来说，这就是两个不同的翻译单元，当然，这样做是没有道理的，并且也可能会报错的。

要建立跨翻译单元的联系，可以通过在两个单元中声明对应的外部链接，比方说上面的全局函数debugInit的声明，可以在两个翻译单元中分别各自做出声明。

## A.2 Declarations and Definitions

在C++程序中声明用来引入或者再次引入一个名字，一个声明也可以是一个定义，取决于引入的实体和引入的方式

- 名字空间和名字空间别名：虽然一个名字空间的成员将来可能会扩展，但其声明总是定义。
- 类，类模板，函数，函数模板，成员函数，成员函数模板：当它们的声明包含用`{}`括起来定义体时，这个声明就是一个定义。这条也适用与union、运算符、成员运算符、静态成员函数、构造函数和析构函数，以及对应显式特化的模板版本。
- 枚举：只要其声明包含`{}`括起来的成员列表就是一个定义。
- 局部变量和非静态成员：这些实体的声明总是被认为是定义，其实也没什么区别。但是要注意，在函数定义中出现的函数参数的声明被认为是定义，而在不是定义的函数声明中出现的参数声明不是定义。
- 全局变量：如果前面没有extern修饰，或者有初始化器，则被认为是个定义，否则就不是。
- 静态数据成员：如果其出现在类或者类模板定义之外，或者在类定义中的声明有inline或者constexpr修饰，则是定义。
- 显式和部分特化：如果在`template<>`或者`template<…>`之后的声明本身就是定义，则其声明是个定义。但是对于静态数据成员或者静态数据成员模板，其显式特化声明只有在包括初始化器时才是定义。

除此之外的声明不是定义。包括类型别名(typedef或者using)，using声明，using导言，模板参数声明，显式初始化导言，static_assert声明，等等。

## A.3 The One-Definition Rule in Detail

### A.3.1 One-per-Program Constraints

一个程序中下面这些项最多只能有一个定义

- 非inline函数和非inline成员函数，包括函数模板的全特化。
- 非inline变量，尤其是在名字空间域和全局域声明并且没有static修饰的变量。
- 非inline的静态数据成员。

比方说一个程序有下面两个翻译单元

```c++
//翻译单元1
int counter;

//翻译单元2
int counter; //重复定义
```

这条规则不适用于内部链接的实体，比方说对于在名字空间域或者全局域声明的变量，加上static修饰后就变成内部链接，从而会被认为是两个实体，并且会相互屏蔽。另外，在不同的翻译单元中的匿名名字空间中声明的实体，会被认为是不同的，只不过要注意，在c++11之前，这样的实体缺省是外部链接的，C++11开始就改变为缺省内部链接了

```c++
//翻译单元1
static int counter=2; 
namespace
{
    void unique(){}
}

//翻译单元2
static int counter=0;
namespace
{
    void unique()
    {
        ++counter;
    }
}

int main()
{
    unique();
}
```

关于匿名名字空间，插一个题外话，比方说上面的翻译单元2的这个匿名名字空间，编译器会自动给其一个随机或者按照某种规则生成的名字，然后using这个名字，这个using导言是个内部链接

```c++
namespace XXXX
{
	void unique()
	{
		...;
	}
}
using namespace XXXX;
int main()
{
	unique();
}
```

更进一步说，在c++17引入的constexpr-if表达式中，不同的分支里可以各自出现前面所说的只能有一个定义的项，也就是说一个程序里边还是可能出现同一个项的多次定义的，当然，这里的语义对人来说是知道不会有冲突的，但是对于编译器，首先在进行句法分析时，必须明确这样的句法是合法的，然后到语义分析阶段，选择分支，最后形成代码，到了这个时候，冲突就不存在了。这里涉及到一个形式逻辑上的问题。

除了这个表达式之外，如果要使用这些项，这些项的定义就必须实实在在的存在。这里所谓的使用是有明确含义的，指的是在程序中的某个地方，有对这个实体的某种形式的引用，以用来直接生成代码。这种引用可以是显式的，也可以是隐式的。比方说，一个new表达式可能隐含着对delete操作的调用，以便处理构造函数抛出异常从而需要清理已分配但未使用的内存。在比方说复制构造函数，即便有可能被优化掉，但也还是必须定义的。虚函数也是会被隐含使用的，比如用来构建虚表。另外必须强调的是这里的使用是一种状态，而不是一个动作。

从前述的意义上讲，有些引用并不构成使用，这指的是不要求值的操作数，这里所谓的求值，并不仅仅只是指对数值表达式的求值，而是从更广泛的意义上，确定一个对象的地址及该地址中存放的数据，而操作数，指的是运算符操作的对象，并不仅仅是个数值。

比方说sizeof和decltype的操作数就是不需要求值的操作数。而typeid的操作数，只是在某些情况下不需要求值。特别的说，如果一个引用作为typeid的参数不是一个多态对象，那么就不会被认为是使用。所谓多态对象，指的是有虚函数的对象。比方说

```c++
class Decider
{
#if defined(DYNAMIC)
    virtual ~Decider(){}
#endif
};

extern Decider d;

int main()
{
    char const* name=typeid(d).name();
    return (int)sizeof(d);
}
```

如果没有定义DYNAMIC，这段程序就是合法的。确实，这里d只是个声明，并不是定义，sizeof没有问题，而如果没有定义DYNAMIC，则typeid对d的引用就不是使用，所以也没问题，但是如果定义了DYNAMIC，则对d的引用就是一个使用，于是出错了。通常来说，对一个多态对象而言，typeid只有到了运行时才能确定其结果，而对于sizeof和decltype来说，成员函数定义与否并不影响其结果。

按照C++标准，这一节所说的问题如果出错都是在链接时报告重复定义或者缺少定义。

### A.3.2 One-per-Translation Unit Constraints

ODR指明了在某些情况下某些实体必须有定义，这些包括类类型，inline函数，inline变量。

一个翻译单元中的类类型X，在被如下方式使用前，必须要有定义

- 创建一个类型X的对象，包括变量声明或者new表达式。这种创建可以是间接的，比如创建一个对象，这个对象里边包含了一个类型X的对象。
- 类型X的数据成员声明
- 对一个X类型的对象使用sizeof或者typeid。注意这里是对一个翻译单元而言，与前一节的讨论并不矛盾。
- 显式或者隐式的访问类型X的成员。
- 通过任何形式的转换将一个表达式转成类型X，或者从类型X转换过来。通过隐式转换，static_cast，或者dynamic_cast将一个表达式转换成类型X的指针或者引用，或者反过来，void*除外。
- 赋值一个类型X的对象。
- 定义或者调用一个函数，该函数的某个参数或者返回值是类型X。不过仅仅是函数的声明则不需要类型X的定义。

这些规则也适用于类模板生成的类型X，这里就引出来POI的概念，可参见14.3.2。

inline函数在其被使用的翻译单元中必须有定义，不过，与类类型不同，他们的定义可以出现在使用点之后。

```c++
inline int notSoFast();

int main()
{}

inline int notSoFast()
{}
```

不过，这情况下，在未看到具体定义前，有些编译器不一定会把这个inline函数真正inline处理。

同样，参数化函数(函数模板、成员函数模板、类模板的成员函数)的定义也可以出现在POI之后。

这一节所讨论的内容很容易由编译器诊断，因此如果违反了前面规则的话，标准要求编译器为此发出诊断信息。不过，参数化函数的定义缺失通常不做检查。

### A.3.3 Cross-Translation Unit Equivalence Constrains

允许在多个翻译单元中定义某种实体会带来一个新的问题：多个不匹配的定义。对于一次处理一个翻译单元的传统编译器来说，这种错误很难发现。因此，C++标准实际上是允许这种行为的，并且只是认定这是未定义行为，如何诊断并界定这种行为，依赖于编译器实现。

跨翻译单元限制指明如果一个实体在两个不同的地方定义，那么这两个地方必须保持同样的标签序列，这里标签指的是经过预处理之后留下来的关键字、运算符、标识符等等，并且，这些标签在其各自的上下文中必须指的是同样的东西，比方说标识符必须指的是同一个变量。

```c++
//翻译单元1
static int counter=0;
inline void increaseCounter()
{
    ++counter;
}
int main()
{
}
```
```c++
//翻译单元2
static int counter=0;
inline void increaseCounter()
{
    ++counter;
}
```

上面例子出错的原因在于counter指的是两个无关的实体，至于increaseCouter则是其次，并且与这个错误无关。

把可能会被多个翻译单元使用的实体放在头文件可以保证大多数时候标签序列的一致性，当然，如果出现条件编译导言那又是另外一回事，所以要谨慎使用这样的导言。

跨翻译单元现在不止适用于实体，还适用于在声明中出现的缺省参数。下面的例子就会是个未定义行为

```c++
void unused(int =3);
int main()
{}
```

```c++
void unused(int =4);
```

这里要注意标签流的相等性有时可能会包含一些隐含的效果：

```c++
//翻译单元1
class X
{
    public:
    	X(int,int);
    	X(int,int,int);
};

X::X(int,int=0)
{}

class D
{
    X x=0;
};

D d1;  //D()会调用X(int,int)
```

```c++
//翻译单元2
class X
{
    public:
    	X(int,int);
    	X(int,int,int);
};

X::X(int,int=0,int=0)
{}

class D: public X
{
    X x=0;
};

D d2; //D()会调用X(int,int,int)
```

这里的问题在于隐含生成的类D的缺省构造函数在两个翻译单元里边是不一样的，原因就在于`X x=0;`这一句，由于两个翻译单元中X的两个构造函数使用了不同缺省参数，各自处理的时候D的构造函数就会调用了X的不同的构造函数。这里问题并不在于D是否X的子类。所以，不要把缺省参数放到类外定义中。

关于同样的标签必须指向同一个实体这条规则的一个例外是，如果同样的标签指向值相同但无关的常量，并且结果表达式的地址没有被使用，那么这些标签也被认为是相等的。比方说

```c++
#ifndef HEADER_HPP
#define HEADER_HPP

int const length=10;
class MiniBuffer
{
    char buf[length];
    ...
};
#endif
```

如果这个头文件被两个不同的翻译单元包含，那么就会创建两个名字都叫length的不同实体，因为在这个上下文中，const隐含着static。但是，这样的常量通常是在定义编译期常量，而不是一个运行时的存储位置，所以，如果没有强制使得这样一个地址存在，比方说用引用这个变量的地址，那么这两个常量有同样的值也是可以的。

最后，关于模板。模板中的名字在两个阶段绑定，非依赖性名字在模板定义的地方绑定，对于这些名字，其相等性规则与其他非模板定义的名字类似处理，而在模板实例化的地方绑定的名字，相等性规则必须在那一点应用，并且绑定必须是相等的。





