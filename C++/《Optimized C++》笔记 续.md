

[TOC]
# Chapter 7 Optimize Hot Statements

在语句层面的优化可以认为是一个把指令从执行流中移除的过程。这里的问题在于，除了函数调用之外，C++的语句单独都不会占用太多的机器指令。不过有一些因素会放大这些语句的耗费：

- 循环。profiler可以指出一个函数里边有热循环，但并不会说是哪一个循环。也可以指出一个在循环内调用的函数是热点，但并不会说是在什么地方被调用的。也就是说，profiler并不能直接指向到循环，必须有程序员自己去查找。
- 频繁调用的函数。通常profiler可以直接指向热点函数。
- 程序中的一些习惯用法。可以考虑代价更低的惯例。

对于桌面和集群级的处理器而言，由于指令级的并发和缓存机制，对于语句级的优化效果并没有对内存分配和复制的优化效果显著。所以对于桌面级应用，语句优化也只适用于频繁调用的库函数以及程序中最内层的循环，比方说游戏图形引擎和整天都在运行的可编程语言翻译器。

语句优化的另外一个问题是优化的效果依赖于编译器实现。这也是语句优化效果相比较而言不是那么显著的另一个原因。

## Remove Code from Loops

一个循环有两个部分：一个是循环体，一个是循环控制。通常都是从循环体中移除语句，不过对于循环控制也是有优化机会的，比方说

```c++
char s[]="This string has many space (0x20) chars. ";
for(size_t i=0;i<strlen(s);++i)
{
    if(s[i]==' ')
        s[i]='*';
}
```

显然每次迭代对`i<strlen(s)`的检测会使得这个算法从$O(n)$变成$O(n^2)$。strlen有一个隐藏在库函数内部的循环。

### Cache the Loop End Value

所以这里应该这样

```c++
for(size_t i=0,len=strlen(s);i<len;++i)
{
    ...
}
```

不过，按道理说现代编译器应该会自己把strlen的结果提取并缓存，这是一个很明显的循环不变量。

### Use More Efficient Loop Statements

对于for循环，编译器大产生的代码大体上是这样的

```c++
	initial-expression;
L1:	if(!condition) goto L2;
	controlled-statement;
	continue-expression;
	goto L1;
L2:
```

而对于do while语句，大体上是这样

```c++
L1: controlled-statement
    if(conditon) goto L1;
```

显然比for少了一次跳转，所以从理论上说，程序可以改成这样

```c++
size_t i=0,len=strlen(s);
do{
    if(s[i]==' ')
        s[i]='*';
}while(i<len);
```

不过，还是那句话，对于循环的优化，现代编译器已经做得很好了，所以除非用特定的编译器比较过结果，用for循环通常是没有什么问题的。

### Count Down Instead of Up

缓存结束值的另一种做法是递减计数

```c++
for(int i=(int)strlen(s)-1;i>=0;--i)
{
    ...
}
```

与前面的例子没有本质区别，不过注意这里循环变量是int，这是一个有符号数，size_t是无符号的，在递减计数是要特别注意，因为无符号数总是`>=0`的。

### Remove Invariant Code from Loops

前面的strlen已经是一个循环不变量的例子了，我们再看看其他的

```c++
int i,j,x,a[10];
...
for(i=0;i<10;++i)
{
    j=100;
    a[i]=i+j*x*x;
}
```

显然，这里应该这样

```c++
int i,j,x,a[10];
...
j=100;
int tmp=j*x*x;
for(i=0;i<10;++i)
{
	a[i]=i+tmp;
}
```

不过还是那句话，这个工作编译器通常可以自己做的，但是作为一个程序员，不要走循环中定义无关的变量应该是一个常识。而如果在循环中调用函数，编译器并不能确定其返回值是否一个循环不变量，这个工作就需要程序员来处理了。

### Remove Unneeded Function Calls from loops

对于这样的代码

```c++
UsefulTool subsystem;
InputHandler input_getter;
...
while(input_getter.more_work_available())
{
    subsystem.initialize();
    subsystem.process_work(input_getter.get_work());
}
```

是否可以把`subsystem.initialize();`移到循环外，需要看情况而定。但是，这种地方总是需要关注的。

### Remove Hidden Function Calls from Loops

隐含的函数调用包括这些

- 声明类实例(调用构造函数)
- 初始化类实例(调用构造函数)
- 类实例赋值(赋值操作符)
- 包括类实例的算术表达式(调用成员操作符)
- 退出作用范围(调用类实例的析构函数)
- 函数参数(每一个实际参数表达式都会复制构造到对应的形式参数)
- 函数返回的类实例(调用复制构造函数，可能两次)
- 向标准容器插入元素(元素是移动或者复制构造的)
- vector这样的容器如果插入数据时引发重新分配，其中的元素也需要移动或者复制构造到新的空间

构造函数形式参数导致的隐藏函数调用可以通过传递引用或者指针来移除。

复制函数返回值导致的隐藏函数调用可以通过使用输出参数，也就是在参数列表中用于返回结果的参数，这类参数都是引用或者指针类型。

如果赋值或者声明是个循环不变量，那么可以将其移除循环外。如果一个变量每次迭代都需要改变状态，可以寻找代价较小的状态改变方式，比方说

```C++
for(...)
{
    std::string s("<p>");
    ...
    s+="</p>";
}
```

可以改成这样

```c++
std::string s;
for(...)
{
    s.clear();
    s+="<p>";
    ...
    s+="</p>";
}
```

这里不但减少了s的构造和析构函数的调用，而且s的空间还可以复用，可能可以减少一些对内存管理的调用。

### Remove Expensive,Slow-Changing Calls from Loops

有些函数不是不变量，但最好是。比方说日志应用中获取当前时间的调用。可以考虑获取一次时间记录多条日志的方式，不过这个方式要具体而定。

### Push Loops Down into Functions to Reduce Call Overhead

函数调用的代价总是比循环迭代的代价要大。

### Do Some Actions Less Frequently

有这么一个问题，如果一个程序的主循环每秒处理1000个事务，那么要以什么样的频率检查中止循环的命令？事实上，这取决于两件事，一个是对于中止请求的响应时间要求，一个是检查中止条件的代价。

如果需要在一秒钟内响应中止请求结束程序，并且在检测到中止命令后需要$500 \pm 100$毫秒的时间来中止程序，那么就需要每隔400毫秒检查一次(1000-(500+100))，检测次数再多就是浪费。

对于检查中止条件的代价，如果是Windows消息循环，那么对WM_CLOSE这样的消息的检测代价需要派发这个事件，没有额外的代价，如果是通过信号句柄设置一个bool标志，检测这个标志的代价也是微不足道的。

但如果是在一个嵌入式设备中，需要在循环中检测按键消息，而键被按下的消息会有个50毫秒的抖动持续时间，如果循环的每次迭代都去检测一次是否按了退出键，那么处理每个事务的时间就需要加上这50ms的代价，于是本来每秒1000次的处理频度就会变成了$\frac{1000}{51} \approx 20$每秒。但是如果改成每隔400ms处理一次退出按键的消息，为了能在这400ms的间隔里完成一次50ms的按键消息，那么按键消息就需要每隔350ms检查一次，或者每1000毫秒检查2.5次，因此事务处理频度就是$1000-(2.5*50) = 875$次每秒。看看代码就能更好的理解这里到底说了啥

```c++
void main_loop(Event evt)
{
    static unsigned counter=1;
    if((count%350)==0)
    {
        if(poll_for_exit())
            exit_program();
    }
    ++counter;
    switch(evt)
    {...}
}
```

这里假定每1ms进入main_loop一次，`poll_for_exit()`执行需要50ms，`exit_program()`需要大概400-600ms的执行时间。

当然上面只是示意说明，并不代表真是情况，要对这样的情况做优化，需要进行实测，然后确定一个可行的方案。

### Whar About Everything Else?

没什么别的了，很多说法比方说`++i`比`i++`效率高，还有什么循环展开以减少迭代次数，实际上，对于循环的优化现代编译器已经做得很好了，甚至基本上可以认为比人做得更好，所以不需要再去考虑这些犄角旮旯的东西。

## Remove Code from Functions

与循环一样，函数也包括两个部分，函数体，以及函数头，同样，也是可以分别优化的。

函数体执行的代价依函数规模而定，而函数调用的代价相比一次函数执行可能是微小的，但是如果函数需要多次调用，那么这个代价也还是会很显著的。

### Cost of Function Calls

每次函数调用大体上会发生这些事情

- 执行代码向调用栈推入一个帧，这个帧里用来存储函数的调用参数和局部变量
- 每一个参数表达式求值然后将结果复制到上述栈帧里
- 当前执行地址被复制到栈帧以形成返回地址
- 执行代码将执行地址改变为函数体的第一条语句的地址
- 执行函数体的指令
- 返回地址从栈帧复制到指令地址，把控制权转移到函数调用语句的下一条语句
- 栈帧从栈中弹出

这只是对函数调用流程一个形象化的说明，并不代表每次调用的细节，并且要注意的是推入栈的栈帧包含的是数据和地址，而不是指令，冯·诺依曼体系的架构下指令和数据当然是分别存储的。另外inline函数可以就地展开而不是进行调用。

#### Basic cost of function calls

- 函数参数

    除了对参数表达式求值的代价外，把每一个参数值复制到栈也是有代价的。有时候有些参数可以复制到寄存器中，但是如果参数多的话还是需要通过栈传递的。但是由于参数处理的顺序可能会依平台而异，宽泛的说把较小的参数放在左边或者右边都是不合适的。

- 成员函数调用（与普通函数调用相比）

    每一个成员函数调用都有一个隐藏的参数，一个指向`this`的指针，或者说`*this`，或者说this指针，具体怎么说依情况而定。

- 调用和返回

    调用需要把执行地址写入到栈帧中以形成返回地址，返回则需要把返回地址读出来并放入到执行指针中。在调用和返回的时候，执行是在一个非连续的内存地址上，这会造成流水线堵塞以及缓存未命中。

    这两者都是程序执行时的纯负担，所以尽可能把函数的inline化。

#### Cost of virtual functions

每一个有虚函数的类实例都有一个指针，这个指针指向vtable，或者说虚函数表，这个指针通常通常存在于类实例的最前面，以减少访问代价。于是虚函数地址的查找分成两步，一个是找到虚表，一个是在虚表中找到虚函数，这样就增加了两次装载不连续内存的操作，从而增加了缓存未命中和流水线堵塞的概率。

另外，通常来说，由于动态性，虚函数是很难inline化的。

#### Member function calls in derived class

派生类的成员函数调用需要一些额外的工作

- 派生类中定义虚成员函数

    如果继承树上的基类都没有虚函数，那么定义了虚函数的派生类实例就需要增加一个虚表指针，并且这个虚表指针在这个类实例的位置会有个偏移，而不是在最前面，这会增加访问虚表的代价。

- 多重继承的派生类中定义的成员函数

    为了能够访问多个基类中的函数，同样也需要加上偏移，也会增加代价

- 多重继承的派生类中定义的虚函数

    对于一个多重继承的类，如果其某个不是最底层的基类定义了虚函数，那么为了寻找虚函数，那么就首先需要找到这个基类，然后找到这个基类的虚表，这里可能需要计算两次偏移量

- 虚多重继承

    为了找到被虚继承的基类，需要计算偏移量，如果要调用虚函数，那么同样也还要计算虚表的偏移

#### Cost of pointers to functions

对于函数指针，在函数调用和返回的基本代价之外，还有些额外的代价

- 函数指针（普通函数和静态成员函数）

    需要解引用，并且也不太可能inline化

- 成员函数指针

    成员函数指针需要足够通用以能够调用任意的成员函数。对于成员函数指针，做任何最糟糕的评估都不是没有理由的。

#### Summary of function call costs

不带参数的void的C风格的函数是代价最小的，如果可以inline化则没有任何代价，否则也只有两次内存访问加上两次非本地的执行跳转。

如果一个虚函数属于一个基类没有定义虚函数的派生类，而这个派生类又被虚继承，这是一种最糟糕但不太常见的情况，首先需要查找一个表，找到这个虚基类，然后再查找到这个虚基类的虚表，然后在虚表中查找到虚函数的地址。

到这里，坏消息是移除一次非序列内存访问并不能对优化产生什么太多的效果，除非这个函数会被多次调用，这里非序列内存访问指的是对内存的连续访问操作其内存地址不连续。好消息是profiler能够直接的支持最常访问的函数。

### Declare Brief Functions Inline

要inline化一个函数，编译器必须在函数的调用点能够访问到函数的定义。在类定义内部定义的函数隐含的声明为inline，而在外部定义的可以加上inline关键字。虽然标准只是说inline是个提示，但编译器总是尽可能的inline化一个函数的。实际上，一个程序的debug版本和Release版本的区别主要就在于debug版本关掉了inline。

### Define Functions Before First Use

在函数的调用点之前完整地定义函数可以让编译器有机会优化函数调用，这对于虚函数也是有效的，只要编译器在虚函数被调用时能够看到完整的函数体和实例化类变量、指针或者引用的代码。

### Eliminate Unused Polymorphism

如果必须在运行时对不同的实现做出选择，虚函数表是一种非常快捷的机制，尽管会需要两次额外的内存装载和潜在的流水线堵塞以及缓存未命中。如果实际上并不需要这种动态的多态机制，那么取消掉函数声明的virtual限定符也是可以考虑的，比方说在一个层级结构中，各层的类都以指针联系起来了，这个时候是不需要虚函数的。

### Discard Unused Interfaces

接口的好处之一是派生类必须实现接口中声明的方法，否则编译器就会报错。但是如果一个应用只提供了一个单一的实现，那么这时候可以考虑把接口变成一个普通的基类类，也就是把成员函数声明前的virtual去掉，并提供哪怕一个空实现，然后在单一的派生类的实现中实现所需的操作。将来需要的话，再加上virtual也是可以的，这时候并不需要改动原有的派生类实现。

#### Select interface implementation at link time

使用虚函数来实现接口的问题在于，对于一个设计期的问题，虚函数提供了一个运行时解决方案，这个方案带来了运行时代价。

有一些使用同一个接口的应用实际上是需要共存的，比方说一个对应文件系统的接口，Windows和linux的实现并不需要同时存在。这时候虚函数的代价是不必要的。这时候可以通过在链接的时候指定合适的翻译单元来完成构建。

比方说一个头文件file.h，里边声明了File类，但没有实现

```c++
class File
{
	...
};
```

对应这个头文件，提供两个各自对应两个平台的实现，比方说windowsfile.cpp和linux.cpp，在构建的时候就可以通过编译参数来决定链接哪个翻译单元。

这样的好处在于非常的通用化，不足之处在于需要.cpp文件和makefile来决定选择。

#### Select interface implementation at compile time

前面说明了由链接器来做选择的方法，实际上在实现文件中通过#ifdef可以实现在编译时选择，也就是说，在文件file.cpp中

```c++
#include "file.h"
#ifdef _WIN32
...
#else  //linux
...
#endif
```

这里的好处在于在一个文件中就可以看到所有的选择，但是不好的地方在于其繁杂和不是那么的面向对象，因为把所有的东西都放在了一个文件里。

以上两种方法的选择依各人所好。前一种方法在makefile中就可以指定需要编译和链接的翻译单元，并不存在多编译一个文件的问题。而第二种方法确实过于繁杂，个人不喜欢这种方式。

### Select Implementation at Compile Time with Templates

作为模板参数的类型，只有其被使用到的成员才需要实现，只要其成员没有被使用，编译器就不会对模板参数缺少定义报警，而程序员也可以自行选择实现哪些成员。

### Eliminate Uses of the PIMPL Idiom

PIMPL指的是“Pointer to IMPLementation”，可以用来避免一个头文件的改变触发多个源文件的重新编译。但是在运行时，这种方法只会带了延迟，一则可能本来可以inline化的函数需要一次函数调用，二则调用成员函数可能需要调用另一个类的成员函数，三则对于debug来说由于增加了函数调用层次而变得更加乏味。

当然，从设计模式的角度说，组合一个指向其它类的指针是许多设计模式的实现方式，但这不是出于减少重编译的初衷，而是出于解决问题的目的。

### Eliminate Calls int DLLS

对于动态库的调用，都需要使用一个指针，不论是Windows还是Linux。有时候调用动态库是必要的，比方说一个应用可能会使用第三方的库，或者一个库并不想暴露自己的源码。

但是对于并不需要向外提供库的应用来说，没有必要给自己找麻烦使用动态库。如果可能的话，使用静态链接而不是动态链接，这也是提高函数调用性能的方法之一。

### Use Static Member Functions Instead of Member Functions

对成员函数的调用会隐含的传入一个参数，通过这个this指针，可以访问类实例的成员以及虚表等等。但是如果一个成员函数并不需要访问类的其它成员，这个this指针就没有必要，这时候这个成员函数就可以定义成static的，静态成员函数不需要对隐含的this指针求值，本身也可以通过普通的函数指针引用，而不是代价高昂的成员函数指针。

### Move Virtual Destructor to Base Class

拥有子类的类的析构函数应该声明成virtual的，这样在析构一个类时就可以找到正确的类。另外一个原因是，在基类中声明虚函数，可以确保虚表指针位于一个类实例的最前面，以减少计算偏移的代价。

## Optimize Expressions

### Simplify Expressions

### Group Constants Together

### Use Less-Expensive Operator

### Use Integer Arithmetic Instead of Floating Arithmetic

### Double May Be Faster than Float

### Replace Iterative Computations with Closed Forms

## Optimize Control Flow Idioms

### Use Switch Instead of if-elseif-else

### Use Virtual Functions Instead of switch of if

### Use No-Cost Exception Handling

## Summary



