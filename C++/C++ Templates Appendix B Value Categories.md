# Appendix B Value Categories

[TOC]

表达式是C++语言的基石，表达式可以计算，其计算结果的值的静态类型，就是表达式的一个类型。比方说表达式7的类型是int，表达式5+2的类型也是int，如果x的类型是int型变量，则表达式x的类型也是int。

每一个表达式也有一个值范畴，用来表示其值是如何构成的以及是怎样影响表达式的行为的。

## B.1 Traditional Lvalues and Rvalues

历史上，只有两类值：左值和右值。

左值是一个表达式，指向真实的地址，包括内存地址和机器寄存器，比方说，如果x是一个变量名，则表达式x就是个左值。这些表达式可以更改，也就是说可以改变其所存储的值。比方说，x是一个int类型的变，则`x=7`这个表达式就使得x的值被7取代。

左值(lvalue)这个术语来自于赋值中的角色，在c语言中，只有左值可以出现在赋值号`=`的左边，相应的，右值(rvalue)只能出现在右边。

然而，到了C89标准，一个`int const`虽然仍然是一个保存在内存中的值，但其并不能出现在赋值号的左边

```c++
int const x;
x=7;  //Error:左边必须是一个可更改的值。
```

而C++则更进一步，类右值可以出现在赋值号的左边，当然这里的右值是后来意义上的右值，而这里的赋值实际上是对类的赋值运算符函数的一次调用，并不是把一个标量简单的赋给一个类，因此其符合单独的成员函数的调用规则。

所以现在术语左值或者lvalue有时候指的是localization value，这里指的是可定位的值。指向变量的表达式不是唯一的左值表达式，其它的一些左值表达式包括指针的解引用操作(`*p`)，指向成员对象的表达式(`p->data`)。甚至如果一个函数的返回值带有`&`，其调用返回的值也是一个传统意义上的左值引用类型。另外，字符串文本也是左值，虽然是不可更改的。

右值则是与存储无关的纯粹的数学意义上的值，比方说7或者`a`，在计算的时候出现，使用完毕之后就不可再引用。特别的，除了字符串文本之外的所有文本，比如7，`a`，true，nullptr都是右值，以及算术运算的结果和返回值函数也都是右值。也就是说，所有的临时量都是右值。

### B.1.1 Lvalue-to Rvalue Conversions

出于其短暂存在的属性，rvalue必须限制在赋值号的右边，`7=8`这样的赋值是毫无意义的。而左值，并没有这样的限制，`x=y`就是毫无问题的。原因在于在这里，y有一个隐含的左值到右值的转换。这个转换完成了两件事情，首先是确保左值可以出现在右值应该出现的地方，其次，定义了程序中的一个点，在这个点编译器会发出装载指令以从内存获取值。

## B.2 Value Categories Since C++11

当为了支持移动语义，C++11引入右值引用之后，传统的左右值的分类就不足以描述C++11的所有语言特性了。C++标准委员会为此设计了值范畴，包括三个核心类别和两个组合类别。核心类别是：lvalue，prvlaue("pure rvalue”)，xvalue。组合类别是：glvalue(“generalized lvalue”，lvalue和xvalue的并集)，rvalue(xvalue和prvalue的并集)。

要注意所有的表达式仍然要么是左值要么是右值，只不过右值类别现在细分了。

在C++17中，对这些特性又做了重新描述

- 一个glvalue是一个表达式，其求值决定了对象、位域或者函数的实体，也就是可存储的实体。
- 一个prvalue是一个表达式，其求值初始化一个对象或者一个位域，或者计算一个操作符的操作数的值。
- 一个xvalue是一个glvalue，指明一个资源可重复使用的对象或者位域，通常是即将过期的，xvalue便来自e**X**piring value。
- 一个lvalue是一个不是xvalue的glvalue，也就是不会马上过期的glvalue。
- 一个rvalue是一个prvalue或者xvalue的表达式。

从这些描述，可以总结下，原来的左值还是左值，原来的右值现在是prvalue，而前面所说的那些临时量现在归入xvalue。xvalue传统上是应该被看做右值，但是由于语言的发展，使其又有了左值的一些特性，所以被归入了一个新的分类xvalue。

除了位域之外，glvalue表达式产生一个有地址的实体。这个地址可能是一个更大的对象的子对象的地址。对于一个基类子对象，其类型称为这个glvalue表达式的静态类型，而以这个基类为子对象的派生类的类型则称为这个glvalue表达式的动态类型。如果没有产生基类子对象，则其静态和动态类型是一致的，也就是这个表达式的类型。

lvalue的一些例子

- 命名变量或者函数的表达式
- 内置的一元操作符`*`(解引用)的使用结果
- 字符串文本
- 对返回值是左值引用的函数的调用

prvalue的一些例子

- 非字符串文本和用户自定义文本的文本表达式
- 内置的一元操作符`&`(取地址)的使用结果
- 内置的算术运算的使用结果
- 对返回值是非引用的函数的调用
- Lambda表达式

xvalue的一些例子

- 对返回值是对一个对象的右值引用的函数的调用，比如`std::move()`
- 一个右值引用像一个对象类型的转换。

注意对函数类型的右值引用产生一个左值，不是xvalue。

必须强调的是上面这些都是指的表达式，不是值或者实体。比方说，一个变量不是左值，尽管一个标识变量的表达式是一个左值。

```c++
int x=3;  //x是个变量，3是一个纯右值，在x=3这个表达式里用来初始化x
int y=x;  //这里x是一个左值，这个左值表达式的估值并不产生3这个值，而是指明一个保存了3这个值的地址。
		  //然后这个左值被转换为一个纯右值，用来初始化y。
```

### B.2.1 Temporary Materialization

前面提到左值通常会承担一个左值到右值的转换（或者在C++11的语境下，称为glvalue-to-prvalue的转换更合适），因为prvalue总是用来初始化对象的表达式，或者作为内置运算符的操作数。

C++17中也有一个相对的转换，叫做temporary materialization，也叫做prvalue-to-xvalue的转换：在一个期待glvalue(包括xvalue)出现的地方，如果一个prvalue的出现是合法的，那么就会创建并用这个prvalue初始化一个临时对象，然后这个prvalue就会被一个指示这个临时对象的xvalue取代。比如

```c++
int f(int const&);
int r=f(3);
```

因为`f()`有一个引用形式参数，期待一个glvalue实际参数，而3是一个prvalue，于是表达式3被转换成一个xvalue的临时对象，并用3这个值来初始化。

更一般的来说，一个实体化的临时对象，在下列情况中由一个prvalue初始化：

- 绑定到引用的prvalue（比如上面`f(3)`的调用）
- 访问一个类prvalue的成员
- 获取一个数组prvalue的下标，指用下标访问数组元素
- 一个数组prvalue转换成一个指向其首元素的指针，或者说数组退化
- 出现在花括号初始化列表中的prvalue，比如，对某个类型X，用来初始化一个`std::initializer_list<X>`类型的对象
- sizeof或者typeid应用到prvalue时
- 一个prvalue在`expr;`形式的语句或者在一个转换成void的表达式中作为顶层表达式时

因此，在C++17中，是否用一个prvalue来初始化一个对象是由上下文决定的，并且，产生的结果就是一个临时对象只有在需要的时候才会创建。C++17之前，prvalue(特别是类类型)总是意味着一个临时对象。对于这些临时对象的复制有时候可以略去，但是编译器仍然需要复制构造函数的语义限制，比方需要复制构造函数可调用。下面例子说明了C++17中对这些规则的修订：

```c++
class N
{
    public:
    	N(); 
    	N(N const&)=delete;  //这个类不能复制
    	N(N&&)=delete;       //也不能移动
};
N make_N()
{
    return N{}; 
}
 auto n=make_N();  
```

在C++17之前，prvalue `N{}`会生成一个类型为N的临时对象，不过编译器可以省略这个临时对象的复制或者移动，这也意味着调用`make_N()`产生的临时对象可以直接用来初始化n，然而，C++17前的编译器仍然需要检查确定可以进行复制或者移动操作，但这两个函数已经被删除了，所以在C++11和C++14这里会报错。

C++17中，prvalue`N{}`自己不会产生一个临时对象，而是根据上下文初始化一个临时对象，比方说这里的n。没有复制或者移动需要考虑，这不是一项优化，而是一项语言保证。

最后用一个例子来总结值类别：

```c++
class X {};
X v;
X const c;

void f(X const&);  	//接受任意值类别的表达式
void f(X&&);    	//只接受prvalue和xvalues，只要它们比前一个声明更匹配

f(v);				//向第一个f传入一个可更改的lvalue
f(c);				//向第一个f传入一个不可更改的lvalue
f(X());				//向第二个f传入一个prvalue(在c++17被实体化为一个xvalue)
f(std::move(v));	//向第二个f传入一个xvalue
```

## B.3 Checking Value Categorie with decltype

对于任意的表达式x，`decltype((x))`可以产生如下的结果

- 如果x是个prvalue，则是type
- 如果x是个lvalue，则是type&
- 如果x是个xvalue，则是type&&

这里`decltype((x))`的双括号是必需的，以避免出现一种情况，比方说表达式x命名了一个变量v，如果没有括号，那么`decltype(x)`就会变成`decltype(v)`，显然这并不是想要的结果。至于别的情况倒是双括号倒是可以不需要的。

对任意表达式e使用类型特性，可以检查其值类别

```c++
if constexpr (std::is_lvalue_reference<decltype((e))>::value)
{
    std::cout<<"expression e is lvalue\n";
}
else if constexpr(std::is_rvalue_reference<decltype((e))>::value)
{
    std::cout<<"expression e is xvalue\n";
}
else
{
    std::cout<<"expression e is prvalue\n";
}
```

15.10.2有详细说明。

## B.4 Reference Types

C++中的引用类型，比方说int&，与值类别通过两种重要方式相互作用。

首先，引用可以限制其可以绑定的表达式的值类别，比方说，一个int&类型的非const左值引用只能由一个int类型的左值表达式初始化。类似的，一个int&&类型的右值引用只能由一个int类型的右值表达式初始化。

其次，使用引用作为函数的返回值影响了对该函数的调用的值类别。具体说就是

- 返回左值引用的函数，对其的一次调用产生一个左值
- 返回一个对象的右值引用的函数，对其的一次调用产生一个xvalue。注意对函数类型的右值引用总是产生左值。
- 返回引用类型的函数，对其的调用总是返回prvalue。

因此

```c++
int& lvalue();
int&& xvalue();
int prvalue();

std::is_same_v<decltype(lvalue()),int&>;  //true
std::is_same_v<decltype(xvalue()),int&&>;  //true
is_same_v<decltype(prvalue()),int>;  //true

int& lref1=lvalue(); //OK,左值引用可以绑定到左值
int& lref2=xvalue(); //错误，左值引用不能绑定到xvalue
int& lref3=prvalue(); //错误，左值引用不能绑定到prvalue

int&& rref1=lvalue(); //错误，右值引用不能绑定到左值
int&& rref2=prvalue(); //OK,右值引用可以绑定到一个prvalue
int&& rref3=xvalue(); //OK，右值引用可以绑定到一个xvalue
```







